---
title: 操作系统-磁盘内存管理
date: 2022-01-05 04:04:43
categories: 
 - 学习
---

cpu cache mesi

mysql 最左匹配原则

chan 底层

mutex rwlock 悲观锁 读多写少

cas  读多写少 无锁map 乐观锁 原子操作

map 线程安全

空结构体 不占内存

切片数组 值类型直接对应内存中的值 引用类型指向内存中存放该值的地址

csp gmp

gc 三色标记 stw 停止 sink 对象池

tcp 查询状态 timewait closewait

# 多线程 goroutine 

# channel 同步 互斥 锁

# 垃圾回收 stw


程序运行时的内存空间（堆栈）

之所以要区分堆和栈，是由于程序需要两种不同特性的内存形似而确定的。在C++中，新建一个对象有两种方式，静态分配和动态分配。

栈由系统进行管理，而堆由程序员自己管理

静态分配（数组）已在代码中定义了大小，编译时完成内存空间的分配

一般来说，静态分配用于初始化已知对象大小的时候，比如int a[10];如果我们能够确定这个数组是10个，我们可以使用这种方式。这种方式所需要的内存在编译期间即可确定，因此操作系统便可以预先确定所指定大小内存给变量，并且可以在变量生命周期结束后自动释放。

动态分配(切片) 无法在编译时确定大小，需要动态分配内存空间

然而在某些场景下，可能需要根据某些情况来申请内存，比如int* a =new int[count];而变量count可能就来自于某个配置文件或者用户手动输入的值。这个时候操作系统就无法再预先确定内存大小，并且不执行到new int[count]这一行代码的时候，是无法知道所要分配的内存大小，因此操作系统分出一块内存，用来进行动态分配。并且规定，动态分配的内存需要由客户端自行管理。

STW(stop the world)，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，Golang进行了多次的迭代优化来解决这个问题。

1.3以前的版本使用标记-清扫的方式，整个过程都需要STW。
1.3版本分离了标记和清扫的操作，标记过程STW，清扫过程并发执行。
1.5版本在标记过程中使用三色标记法。回收过程主要有四个阶段，其中，标记和清扫都并发执行的，但标记阶段的前后需要STW一定时间来做GC的准备工作和栈的re-scan。

强弱三色不变式
从 root set 根节点集合 出发扫描栈空间的对象，及其被引用的对象， 扫描堆的对象，及其引用的对象  
栈内对象的操作无屏障技术
插入屏障 针对堆的扫描黑对白引用，白变灰，最后扫描栈stw
删除屏障 针对堆的扫描黑或灰删除任意引用，被删除的引用变灰，下一轮再回收，造成回收精度低
混合写屏障 扫描栈对象全部标为黑，新增的栈对象也为黑，堆中被删除的引用标为灰，被添加的引用标为灰

屏障

https://zhuanlan.zhihu.com/p/334999060
https://zhuanlan.zhihu.com/p/74853110#:~:text=%E5%9C%A8Golang%E4%B8%AD,%E8%BF%87%E7%A8%8B%E9%9C%80%E8%A6%81STW%E3%80%82

## GMP 调度模型 解决程序里产生的多线程如何调度执行的问题
https://blog.csdn.net/xmcy001122/article/details/119392934

更多的可以看这几篇文章：再见 Go 面试官：[GMP 模型，为什么要有 P？]、Go 群友提问：[Goroutine 数量控制在多少合适，会影响 GC 和调度？]、[work-stealing scheduler]


M G P

全局队列

G goroutine  go func(){...} 包含了当前 goroutine 的状态、堆栈、上下文 轻量一般大小2kb 无数量大小限制。

P Processor 处理器不是真正cpu 默认数量为cpu核心数  连接GM的中间件 使G在M中执行 解决GM模型缺点引入的中间层 含有由G组成的本地队列，固定大小为256。 空则从其余P中work stealing或全局队列中取，满则减半到全局队列。    
所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。

调度器 shed

M machine 实际在内核中工作的线程 默认最大10000个，可在程序运行中创建和复用空闲。时分复用执行P的本地队列里的G, 当在执行中的G产生阻塞时，P带着本地队列其余的G转移到一个新建或空闲的M里继续执行其余G。
需要绑定 P 才能进行具体的任务执行的。

总结，Go 调度器很轻量也很简单，足以撑起 goroutine 的调度工作，并且让 Go 具有了原生（强大）并发的能力。Go 调度本质是把大量的 goroutine 分配到少量线程上去执行，并利用多核并行，实现更强大的并发。