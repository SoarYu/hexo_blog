---
title: HTTP笔记
date: 2022-08-13 15:21:43
categories: 
 - 学习笔记
---

# HTTP

## 1、[TCP/IP 的分层管理及主要协议](https://cloud.tencent.com/developer/article/2015535?from=article.detail.1884646)

1. 应用层：应用层决定了向用户提供应用服务时通信的活动。（HTTP、DNS、FTP）


2. 传输层：传输层对上层应用层，提供处于网络连接中两台计算机之间的数据传输。（TCP）


3. 网络层: 网络层用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位。规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。（IP、ARP）


4. 链路层: 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。


5. 物理层: 考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

### 1.1 划分层次
当两台主机之间传送文件时，是一项非常复杂的工作。

可以将工作划分为三类：

1. 与传送文件直接有关，例如发送端的文件传送应用程序应当确定接收端的文件管理程序已做好接收和存储文件的准备。这就需要一个文件传送模块来完成。

2. 为了保证文件和文件传送命令可靠地在两个系统之间交换，可以再设立一个通信服务模块。

3. 再构造一个网络接入模块,让这个模块负责做与网络接口细节有关的工作，并向上层提供服务，使上面的通信服务模块能够完成可靠通信的任务。

### 1.2 分层带来的好处：

1. 各层之间是独立的。某一层并不需要它的下一层是如何实现的，而仅仅需要知道该层接口所提供的服务。

2. 灵活性好。当任何一层发生变化时，只需要层间接口关系保持不变，则在这层以上或以下各层均不受影响。

3. 结构上可分割开。各层都可以采用最适合的技术来实现。

4. 易于实现和维护。整个系统被分解为若干个相对独立的子系统，更方便维护。

5. 能促进标准化工作。每一层的功能及其所提供的服务都有了明确说明。通常各层所要完成的功能主要有以下一些：

　　1）差错控制，使相对应层次对等方的通信更加可靠。

　　2）流量控制，发送端的发送速率必须使接收端来得及接收。

　　3）分段和重装，发送端将要发送的数据块划分为更小的单位，在接收端将其还原。

　　4）复用和分用，发送端几个高层会话复用一条低层的连接，在接收端再进行分用。

　　5）连接建立和释放，交换数据前先建立一条逻辑连接，数据传送结束后释放连接。



## [2、在浏览器中输入url地址后发生的所有过程](https://www.jianshu.com/p/c1dfc6caa520)

1. DNS: 通过DNS将域名解析为目标服务器的IP地址
2. TCP: 获取到目标服务器的IP地址后，发起TCP的三次握手，与目标服务器建立TCP连接。
3. HTTP: 建立TCP连接后，发送HTTP报文向服务器请求资源，TCP会将HTTP请求报文按序号分割成多个报文段，并把每个报文段可靠的传给对方
4. 服务器接受并处理完请求后，返回 HTTP 响应给浏览器客户端。
5. 完成一次 HTTP 请求后，服务器会根据是否是长连接，来决定是不是断开TCP连接。在 HTTP/1.1 中，Connection: keep-alive 是默认启用的，表示持久连接。
在服务器持久连接设定的超时时间（默认75秒）内没有新到达的请求，则断开与客户端的连接。而，浏览器客户端每隔 45 秒会向服务器发送 TCP keep-alive 探测包，
来判断 TCP 连接状况，如果没有收到 ACK 应答，则主动断开与服务器的连接。HTTP keep-alive 和 TCP keep-alive 虽然都是一种保活机制，但是它们完全不相同，
一个作用于应用层，一个作用于传输层。
6. 断开TCP连接 四次挥手
7. 浏览器解析htm代码,并请求htm代码中的资源(如js、css图片等)
8. 浏览器将返回的数据按顺序解析html文件，构建DOM树和CSS规则树生成渲染树。 遇到外部CSS链接时，以异步方式来获取资源，不会产生阻塞并继续加载解析HTML。当 CSS 下载完毕后，主线程在合适的时机解析 CSS 内容。
   但在解析执行JS脚本时，会停止解析后续HTML，可能会出现阻塞问题。
9. 渲染树构建完毕后，根据渲染树的布局，在页面显示的过程中会多次进行Reflow和Repaint操作，计算每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，
改变DOM的外观样式以及大小和位置。

replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。
reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。

浏览器解析css，形成CSS规则树，当DOM树构建完成后，浏览器引擎通过DOM树和CSS规则树构造出渲染树。
渲染树中包含可视节点的样式信息（不可见节点将不会被添加到渲染树中，如：head元素和display值为none的元素）

## 3、URI和URL区别
1）URL是URI的子集，我们所看到的URL是一种特殊的URI，它是URI的一种实现形式，也即一个URL一定是一个URI，但URI不一定是URL
2）URL是绝对的，于整个网络而言，一个提供访问到确切资源的链接是一个URL（也属于URI）
3）URI既有相对性又有绝对性
URI(Identifier) 指定某个资源的唯一识别编号，用身份证号来唯一标识一个人。每个人都有自己的身份证号，对应每个资源有每个资源的URI来作为该资源的标识
知道该资源的唯一标识，并不一定知道该资源的具体位置。每个协议有自己的规范来给该协议下的资源做标识。
URL(Locator)   指定这个资源的路径，类似于具体的身份证卡片，可以通过身份证上的地址来找到每个人的位置。

##  [4、TCP和UDP的区别](https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html#:~:text=%E6%80%BB%E7%BB%93%201%20TCP%E5%90%91%E4%B8%8A%E5%B1%82%E6%8F%90%E4%BE%9B%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%9C%8D%E5%8A%A1%20%EF%BC%8CUDP%E5%90%91%E4%B8%8A%E5%B1%82%E6%8F%90%E4%BE%9B%E6%97%A0%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%8F%AF%E9%9D%A0%E6%9C%8D%E5%8A%A1%E3%80%82%202%20%E8%99%BD%E7%84%B6,UDP%20%E5%B9%B6%E6%B2%A1%E6%9C%89%20TCP%20%E4%BC%A0%E8%BE%93%E6%9D%A5%E7%9A%84%E5%87%86%E7%A1%AE%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B9%9F%E8%83%BD%E5%9C%A8%E5%BE%88%E5%A4%9A%E5%AE%9E%E6%97%B6%E6%80%A7%E8%A6%81%E6%B1%82%E9%AB%98%E7%9A%84%E5%9C%B0%E6%96%B9%E6%9C%89%E6%89%80%E4%BD%9C%E4%B8%BA%203%20%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%87%86%E7%A1%AE%E6%80%A7%E8%A6%81%E6%B1%82%E9%AB%98%EF%BC%8C%E9%80%9F%E5%BA%A6%E5%8F%AF%E4%BB%A5%E7%9B%B8%E5%AF%B9%E8%BE%83%E6%85%A2%E7%9A%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%89%E7%94%A8TCP)

### 4.1 **TCP/IP 是互联网相关的各类协议族的总称**
比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。

**TCP/IP模型**是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。

- 应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。

- 传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。

- 网络层：负责路由以及把分组报文发送给目标网络或主机。

- 链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。

### 4.2 UDP协议 用户数据报协议
UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。

它有以下几个特点：

1. 面向无连接

   首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。 并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。

   具体来说就是： 
   - 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
   - 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作


2. 有单播，多播，广播的功能

   UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。


3. UDP是面向报文的

   发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分， 而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文


4. 不可靠性

   首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。 并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。

   再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。

   这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。


5. 头部开销小，传输数据报文时是很高效的。
   ![UDP Header](/img/http-note/udp-header.png)
   UDP 头部包含了以下几个数据：

   * 两个十六位的端口号，分别为源端口（可选字段）和目标端口
   
   * 整个数据报文的长度

   * 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误

   因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的
   
 udp特点：面向无连接不需要向tcp一样三次握手建立链接（加UDP头、去IP头就可以发送接受数据）、 
 面向报文（对应用层下发的数据包加上UDP头就发给IP层，不会对数据包进行合并和拆分）、 
 单播多播广播都可、 
 不可靠性 不需要建立链接 随时可以发送和接受数据，没用拥堵控制不会考虑网络条件好坏，造成弊端是在网络条件差的时候存在丢包现象
 优点是速率高，适用于实时性要求高的场景。

### 4.3 TCP

TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。
TCP 是面向连接的、可靠的流协议。
流就是指不间断的数据结构，你可以把它想象成排水管中的水流。

#### [TCP 三次握手 四次挥手](https://cloud.tencent.com/developer/article/1874945#:~:text=%E5%8E%9F%E5%9B%A0%EF%BC%9A%20%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E8%BF%9E%E6%8E%A5%20%E5%85%B6%E5%AE%9E%E5%9C%A8RFC%20793%20Transmission%20Control%20Protocol%E9%87%8C%E5%B0%B1%E6%9C%89%E6%8C%87%E5%87%BA%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%8E%9F%E5%9B%A0%20The,prevent%20old%20duplicate%20connection%20initiations%20from%20causing%20confusion.)
```
CLIENT                        SERVER

CLOSED                        CLOSED

LISTEN        

SYN_SEND     -> SYN ->

            <- SYN、ACK <-   SYN_RCVD

ESTABLISED   -> ACK ->       ESTABLISED
```
关键字说明：

- SYN：Synchronize Sequence Numbers，同步序列编号
- ACK：Acknowledge Character，确认字符
- SEQ：Sequence Number，序列号

TCP三次握手执行过程：

1. 首先，服务端和客户端都是处于CLOSED状态的，然后服务端启动，监听端口，状态变为LISTEN(监听)状态
2. 客户端为了请求资源，发送连接，发送同步序列号SYN，此时客户端就变成了SYN-SEND状态
3. 服务端接收到客户端请求之后，发送SYN和ACK，然后服务端状态就变成SYN-RCVD状态
4. 客户端接收到信息之后，再次发送ACK，然后变成ESTABLISHED(已确认)状态，服务端接收到返回信息后，状态也变成ESTABLISHED(已确认)状态

TCP协议为什么需要三次握手？为什么不设计成两次握手就可以？

   原因：避免重复连接
   
   主要原因是为了防止旧的重复连接引起连接混乱问题
   
   比如在网络环境比较复杂的情况，客户端可能会连续发送多次请求。如果只设计成两次握手的情况，服务端只能一直接收请求，然后返回请求信息，也不知道客户端是否请求成功。这些过期请求的话就会造成网络连接的混乱。
   
   所以设计成三次握手的情况，客户端在接收到服务端SEQ+1的返回消息之后，就会知道这个连接是历史连接，所以会发送报文给服务端，告诉服务端。
   
   所以TCP设计成三次握手的目的就是为了避免重复连接。为了节省资源，三次握手就可以符合实际情况，所以就没必要设计成四次握手、五次握手等等情况



