---
title: 计算机网络
date: 2022-11-09 21:37:43
categories: 
 - 学习
---

# 一、基础

## 1.1 计算机网络体系结构

计算机网络体系结构，一般有三种：OSI 七层结构、TCP/IP 五层结构

[](/img/computer-networking/structure.png)

1. 应用层HTTP：应用层决定了向用户提供应用服务时通信的活动。（HTTP、DNS、FTP）

2. 传输层TCP 通信端口：（TCP）为应用层实体提供端到端的通信功能，建立处于网络连接中两台计算机之间的数据传输，保证数据包的顺序传送及数据的完整性。传输层则要负责把数据包传给应⽤，但是⼀台设备上可能会有很多应⽤在接收或者传输数据，因此需要⽤⼀个编号将应⽤区分开来，这个编号就是端⼝。


3. 网络层IP（网络地址）: 网络上有大量节点和路径，网络层负责为在网络上流动的数据包根据其目标地址，选择数据包的下一个目的地以及前往的路径，**数据包**是网络传输的最小数据单位。

规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。（IP、ARP）IP 协议的寻址作⽤是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛，路由则是根据「下⼀个⽬的地」选择路径。寻址更像在导航，路由更像在操作⽅向盘


4. 链路层：MAC地址、路由器（设备实体） 主要为⽹络层提供链路级别传输的服务， 跨网络传输时 每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。

数据链路层把网络层传下来的分组封装成帧。


5. 物理层BIT:网络中数据的传输，最终都需要通过在**物理介质**中传输，物理层提供把数据转换成电信号进行⼆进制BIT传输的服务。

考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

## 1.2 每一层对应的网络协议有哪些？

[](/img/computer-networking/proto.png)

## 1.2 数据在各层之间是怎么传输的?

对于发送方而言，从上层到下层, 层层包装，对于接收方而言，从下层到上层，层层解开包装。

[](/img/computer-networking/transportation.png)

图中的5,4,3,2,1 分别代表TCP/IP协议的应用层、传输层、网络层、数据链路层、物理层，h5,h4,h3,h2代表相应层的控制信息。

这张图展示的是AP1进程向AP2进程传送数据。首先AP1先将数据交给本主机的应用层(第5层)，然后第五层加上必要的控制信息就变成了第四层的数据单元。然后第四层再加上必要的控制信息就变成了第三层的数据单元，以此类推直到第二层(数据链路层)，控制信息变成了首部H2(MAC头地址信息)和尾部T2(FCS:帧校验序列)。 当数据离开路由器到达AP2时，就和上面一样，以此向上最终将数据发送到进程AP2。

* 发送方的应用进程向接收方的应用进程传送数据
* AP先将数据交给本主机的应用层，应用层加上本层的控制信息H5就变成了下一层的数据单元
* 传输层收到这个数据单元后，加上本层的控制信息H4，再交给网络层，成为网络层的数据单元
* 到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）
* 最后的物理层，进行比特流的传输

# 二、 TCP

连接三次挥手，释放四次握手，可靠性保证， 滑动窗口，拥堵控制，流量控制，重传机制 

UDP及其区别


## 2.1 TCP与UDP 概念、区别、联系

[](/img/computer-networking/TCPAndUDP.png)

1. 连接

TCP是面向连接的，在传输前需要三次握手建立连接，UDP不需要连接，即刻传输数据。

UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。 并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。

2. 服务形式（单播，多播，广播）

TCP只能一对一，点对点服务，UDP支持一对一、一对多、多对多通信。

3. 可靠性: TCP可靠、 UDP不可靠

- TCP保证数据可靠交付，拥有确认应答和重传机制，无重复、不丢失、按序到达；UDP尽可能交付，不保证可靠性。

- UDP 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。 并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。

4. 拥塞控制机制

- TCP拥有流量控制、拥塞控制，保证传输安全性等，UDP在网络拥堵情况下不会降低发送速率。

- UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。

这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

5. 首部大小

TCP首部长度不适用选项字段是20字节，使用选项字段长度增加（可变），UDP首部固定8字节（头部开销小，传输数据报文时高效）。

6. 传输方式

TCP基于字节流，没有边界，但是保证传输顺序和可靠性；

UDP继承了IP层特性，基于数据包，有边界可能出现乱序和丢包。

7. 分片方式 (边界)

TCP数据大于MSS时会在TCP层将数据进行分片传输，到达目的地后同样在传输层进行合并，如果有某个片丢失则只需要重传丢失的分片即可；

UDP数据大丁MTU时会在IP层分片，同样也在目的IP层合并，如果某个IP分片丢失，则需要将所有分片都进行重传，开销大。

### 总结:
- TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。
- 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为
- 对数据准确性要求高，速度可以相对较慢的，可以选用TCP

## 2.2 TCP 报文

## 2.2 三次握手



## 2.3 四次挥手



## 2.4  TCP 可靠性保证：  流量控制、拥塞控制、滑动窗⼝（swnd、rwnd、cwnd）、重传机制

校验和CheckSum、 序列号seq、 确认应答ACK、 最大消息长度MSS、 慢启动阀值 ssthresh、 往返时间RTT(Round-trip Time)、 SACK 选择要接受的seq范围

流量控制：滑动窗口cached（swnd、rwnd、cwnd）、重传机制 ACK重复（超时重传、快速重传、SACK、D-SACK）

拥塞控制：慢启动 指数、拥塞避免 线性、拥塞发生 下降、快速恢复


# 三、 IP

# 四、 HTTP/ HTTPS

HTTP: 特性（优缺点）， 报文，状态码和方法， HTTP2， 

HTTPS: 特性（优缺点）， 加密流程

## 4.1 HTTP 基本特性 80

HTTP 超⽂本传输协议

特性：简单、灵活、易于扩展、应用广泛和可以跨平台传输。

1. 简单:
基本报文格式为header＋body，头部信息也是key—value简单文本的形式，易于理解

2. 灵活、易于扩展:
HTTP协议里的各种请求方法、URI／URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充；

3. 无状态：
服务器不会去记忆HTTP的状态，每个请求都是独立的。所以不需要额外的资源来记录状态信息，这能减轻服务器的负担。但它在完成有会话交互性的操作时会非常麻烦。

比如当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第
二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏
览器。

4. 明文传输：
传输过程中的信息，是可方便阅读的，通过浏览器的F12控制台或抓包都可以直接肉眼查看为我们调试工作带来了极大的便利性，但信息透明，容易被窃取。

5. 不安全：
 1．通信使用明文（不加密），内容可能被窃听
 2．不验证通信方的身份，因此有可能遭遇伪装
 3．无法证明报文的完整性，所以有可能已遭篡改。
可以用HTTPS的方式解决，也就是通过引入SSL／TLS层，使得在安全上达到了极致。

## 4.2 HTTPS基本特性 443 = HTTP + 密文 + 验证 + 完整性

HTTPS 超⽂本安全传输协议 

HTTP：以明文的方式在网络中传输数据

HTTPS解决HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL／TLS安全协议，使得报文能够加密传输。

HTTPS在TCP三次握手之后，还需进行SSL／TLS的握手过程，才可进入加密报文传输。HTTP的端口号是80，HTTPS的端口号是443。

HTTPS 协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。
1. 特点：
 - 信息加密：交互信息无法被窃取
 - 校验机制：无法篡改通信内容，篡改了就不能正常显示
 - 身份证书：证明报文的完整

2. 优点
 - 在数据传输过程中，使用秘钥加密，安全性更高
 - 可认证用户和服务器，确保数据发送到正确的用户和服务器

3. 缺点
 - 握手阶段延时较高：在会话前还需进行SSL握手
 - 部署成本高：需要购买CA证书；需要加解密计算，占用CPU资源，需要服务器配置或数目高
 
4. 加密方式
    1. 对称加密：
    只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换；

    2. 非对称加密：
    使用两个密钥，公钥可以任意分发而私钥保密，解决密钥交换问题，但速度慢。

    3. 混合加密：
    实现信息的机密性，解决窃听风险；

HTTPS采用对称加密和非对称加密结合的［混合加密］方式。

### 4.2.5 HTTPS 工作加解密流程

[](/img/computer-networking/https.png)

1. 客户端发起 HTTPS 请求，连接到服务端的 443 端口。
2. 服务端有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。
3. 服务端将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。
4. 客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。
5. 客户端将公钥加密后的密钥发送到服务器。
6. 服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。
7. 服务器将加密后的密文返回到客户端。
8. 客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。

## 4.3 HTTP 请求和响应的报文组成、方法、状态码

请求行 + 请求头Header + 请求体Body
```
1、请求行:（请求方法； URL；协议版本号）
* 请求方法: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, TRACE 
* 协议版本号： HTTP版本号
例如： POST  /chapter17/user.html  HTTP/1.1

2、请求头：包含请求的附加信息，有key： value组成

3、请求体：承载多个请求参数的数据。含回车、换行和请求数据（并非都有）
```

服务器处理请求并返回HTTP报文
```
响应报文主要由响应行、响应头和响应主体构成。
1、相应行: （协议版本；状态码；状态码描述）
2、状态码规则
200：客户端请求成功
206：partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围
301（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URL之一
302（临时重定向）：请求的资源现在临时从不同的URI中获得
304：如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304，该响应不
包含包体（即可直接使用缓存）
400：请求报文语法有误，服务器无法识别
401：请求需要认证
403：请求的对应资源禁止被访问
404：服务器无法找到对应资源
500：服务器内部错误
503：服务器正忙
```



# 五、网络综合

## 2.1 Socket 套接字, 类似特殊的IO流(网络数据)

IO 文件流的读写 <-----> Socket 网络通信中数据流的发送与接收

Socket 一个是 网编编程的标准接口。具体来说，Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。

具体的网络进程通信中，需要确定进程间通信使用的 IP 地址 + 端口 + 协议，三者组合起来就可以称为一个Socket, 利用这个Socket提供的各种函数如:connect、bind、listen、close、accept等函数，来实现网络中进程之间的通信。

## 2.2 Session、 Cookie 概念、区别、 联系

### 2.2.1 Cookie

保存在**客户端**的一小块**文本串**的数据。 客户端向服务器发起请求时， 服务端会向客户端发送一个Cookie, 客户端就把Cookie保存起来。 在客户端下次向同一服务器再次发起请求时，Cookie被携带发送到服务器。服务端可以根据这个Cookie判断用户的身份和状态。**Cookie可存储的数据量有限，一般不超过4KB.**

### 2.2.2 Session

Session与Cookie类似，都是为了存储用户相关信息。它是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，**服务器把客户端信息以某种形式记录在服务器上**，这就是session。客户端浏览器再次访问时只需要从该session中查找用户的状态。

- 优势：数据存储在服务器更加安全

- 缺陷：会占用服务器资源

### 2.2.3 联系

[](/img/computer-networking/sessionAndCookie.png)

1. 用户第一次请求服务器时，服务器根据用户的信息，**创建对应的 Session**，请求返回时将此 Session 的唯一标识信息 **SessionID** 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会**将此信息存入 Cookie 中**，同时 Cookie 记录此 SessionID 是**属于哪个域名**。

2. 当用户第二次访问服务器时，请求会自动判断**此域名下是否存在 Cookie 信息**，如果存在，则自动将 Cookie 信息也发送给服务端，**服务端从 Cookie 中获取SessionID**，再根据 SessionID 查找对应的 Session 信息，如果没有找到，说明用户**没有登录或者登录失效**，如果找到 Session 证明用户**已经登录**可执行后面操作。

### 2.2.4 分布式环境下Session怎么处理呢？

分布式环境下，客户端请求经过负载均衡，可能会分配到不同的服务器上，假如一个用户的请求两次没有落到同一台服务器上，那么在新的服务器上就没有记录用户状态的Session。这时候怎么办呢？

可以使用Redis等**分布式缓存**来存储Session，在多台服务器之间共享。


### 2.2.5 客户端无法使用Cookie怎么办？

有可能客户端无法使用Cookie，比如浏览器禁用Cookie，或者客户端是安卓、IOS等等。这时候怎么办？SessionID怎么存？怎么传给服务端呢？

- 禁用 Cookie 怎么存储 SessionID呢？ 可以使用客户端的本地存储，比如浏览器的sessionStorage。

- 怎么传客户端的 SessionID 给服务器呢？

1. 拼接到URL里：直接把SessionID作为URL的请求参数
2. 放到请求头里：把SessionID放到请求的Header里，比较常用。

