---
title: 操作系统
date: 2022-11-09 21:37:43
categories: 
 - 学习
---

# 基础

## 数据在线路上的传送方式
1. 单工定义：单意思就是A只能发信号，B只能接收信号，通信是单向的。类比于灯塔发发出光信号，航船只能接收信号。

2. 半双工定义：半双工数据传输允许数据在两个方向上传输，但是在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信。举例：指A能发信号给B，B也能发信号给A，但这两个过程不能同时进行。

可以想象一下对讲机，你收到的回复并不是都马上就有的。而且前提是双方不能在同一个状态，如果双方同时处于收状态，或同时处于发状态，便不能正常通信了。

3. 全双工定义：全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。

在A给B发信号的同时，B也可以给A发信号。典型的例子就是打电话，双方都能说，对方也能听到。网卡的全双工是指网卡在发送数据的同时也能够接收数据，两者同步进行。网卡一般都支持全双工。对于全双工以太。

## 1.1 什么是操作系统

可以这么说，操作系统是在硬件资源之上，应用程序之下，运行在内核态的软件。
它是应用程序和硬件之间的媒介，向应用程序提供硬件的抽象，以及管理硬件资源。

## 1.2 操作系统四大功能模块

内存管理、进程管理、⽂件系统管理、输⼊输出设备管理
1. 进程调度能力：管理进程、线程，决定哪个进程、线程使用CPU。
2. 内存管理能力：决定内存的分配和回收。
3. 硬件通信能力：管理硬件，为进程和硬件之间提供通信。
4. 系统调用能力：应用程序进行更高限权运行的服务，需要系统调用，用户程序和操作系统之间的接口。

## 1.3 用户态、内核态

1. 权限：对硬件操作的权限：IO读写、内存分配等。

操作系统把一切对硬件的操作都对用户态的应用程序进行隐藏，应用程序是无法直接执行硬件使用和内存申请等操作。需要通过操作系统提供的**接口（函数库）（系统调用）切换成内核态**， 来完成上述需要高级权限的操作。

2. 空间：用户空间、内核空间。 

每个进程创建都会分配「虚拟空间地址」，一部分为内核空间，另一部分为用户空间。

用户态进程：只能操作用户空间的低位虚拟空间地址。

内核态进程：用户空间和内核空间的虚拟空间地址都可以操作。

补充：所有进程的内核空间地址是共享的（指所有进程的内核态逻辑地址是共享同一块内存地址），是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据

每个进程的 4G 虚拟空间地址，高位 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用，换句话说就是， 高位 1G 的内核空间是被所有进程共享的！

最后做个小结，我们通过指令集权限区分用户态和内核态，还限制了内存资源的使用，操作系统为用户态与内核态划分了两块内存空间，给它们对应的指令集使用

[从根上理解用户态与内核态](https://zhuanlan.zhihu.com/p/388057431)

中断：主要是用来打断cpu执行顺序的一种机制，CPU默认是按照代码的逻辑顺序来一条条执行的，运行起来后是属于不可控的（如果没有中断，你不能在执行的时候强行打断它），如果有键盘输入或者啥的紧急信号，输进来，你得去立刻处理吧，处理的话，要cpu吧，那中断就提供了一个乱序执行的机制，允许你暂停当前的执行，然后到中断中处理，处理完了，再接着执行，无缝衔接。中断是一个专门做这种事的系统。假如没这个系统，cpu正在处理某个数据，要10s才能处理完成，完成后还需要执行到键盘这部分的代码，才能处理键盘的数据，是不是觉得会很卡呢？

两者切换



# 程序、进程、线程

## 程序、进程、线程的区别与概念

- 程序：是一个静态的概念，一般对应于操作系统中的可执行的文件。当程序被加载到内存中执行时，这个运行的程序就被称为进程。

- 进程：是一个动态的概念，系统运行一个程序即是一个进程从创建，运行到消亡的过程，操作系统进行资源调度和分配的基本单位。

- 线程： 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。


## 2.1 进程

进程基本概念、 PCB组成、 进程状态、 进程切换、 进程间通信、 父进程；子进程；僵尸进程；孤儿进程 


### 1.2.1 PCB组成

PCB : 进程控制块

- 操作系统对进程的感知，是通过进程控制块 **PCB数据结构** 来描述的。它是进程存在的**唯一标识**

系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志。进程与PCB是一一对应的。

通常PCB应包含如下一些信息：
1. 进程标识符 name
    每个进程都必须有一个唯一的标识符，可以是字符串，也可以是一个数字。

2. 进程当前状态 status
    说明进程当前所处的状态。为了管理的方便，系统设计时会**将相同的状态的进程组成一个链表（队列）**，如就绪进程队列，等待进程则要根据等待的事件组成多个等待队列，如等待打印机队列。

<!-- 3. 进程相应的程序和数据地址
    以便把PCB与其程序和数据联系起来。 -->

4. 进程资源清单
    列出所拥有的除CPU外的资源记录，如拥有的I/O设备， 打开的文件列表等。

5. 进程优先级 priority
    进程的优先级反映进程的紧迫程度，通常由用户指定和系统设置。

6. CPU现场保护区 cpustatus
    当进程因某种原因不能继续占用CPU时（如等待打印机），释放CPU，这时就要将CPU的各种状态信息保护起来，为将来再次得到处理机恢复CPU的各种状态，继续运行。

7. 进程同步与通信机制
    用于实现进程间互斥、同步和通信所需的信号量等。

8. 进程所在队列PCB的链接字（当前PCB所在队列的下一个PCB地址）
    根据进程所处的现行状态，进程相应的PCB参加到不同队列中。PCB链接字指出该进程所在队列中下一个进程PCB的首地址。

9. 与进程有关的其他信息
    如进程记账信息，进程占用CPU的时间等。

### 1.2.2 进程状态

创建 就绪 运行 阻塞  

某个进程在某个时刻所处的状态分为以下几种，运行态running、就绪态ready、阻塞态wait。

对于阻塞状态；比如read系统调用阻塞，进程会占用内存空间，这是一种浪费行为，于是操作系统会有跟内存管理中物理页置换到磁盘一样的行为，把阻塞的进程置换到磁盘中，此时进程未占用物理内存。

我们称之为挂起；挂起不仅仅可能是物理内存不足，比如sleep系统调用过着用户执行Ctrl+Z也可能导致挂起。

除了创建和结束一般有三个状态：

运行态run：该时刻进程占用CPU

就绪态ready：可运行，由于其他进程处于运行状态而暂时停止运行

阻塞态wait：该进程正在等待某一事件发生（如等待输入／输出操作的完成）而暂时停止运行

阻塞态的进程占用着物理内存，在虚拟内存管理的操作系统中，通常会把阻塞态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。

挂起态：新的状态，描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现

就绪挂起状态：进程在外存（硬盘），但只要进入内存，马上运行

特点：

1.就绪态和运行态可以相互转换，其它的都是单向转换。就绪态的进程通过调度算法从而获得CPU时间，转为运行状态;

2.运行态的进程，在分配给它的CPU时间片用完之后就会转为就绪状态，等待下一次调度。

3.阻塞态是缺少需要的资源从而由运行态转换而来，但是该资源不包括CPU时间，缺少CPU时间会从运行态转换为就绪态。

### 进程上下文切换

### 进程间通信 （IPC，InterProcess Communication）|| [进程间通信](https://blog.csdn.net/xiaobai_hellow/article/details/124545527?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124545527-blog-81184434.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124545527-blog-81184434.pc_relevant_recovery_v2&utm_relevant_index=2)

操作系统下不同的进程的操作是互不干扰的（ 独立性，这是因为每个进程都有自己的独特的虚拟地址，这个虚拟地址是由物理内存映射而来的，对于不同的进程，相同的虚拟地址位置会映射到不同的物理内存上，所以进程具有独立性），那么我们难免会遇到一个进程需要另一个进程的东西，那么对于进程间通信，在这些方面就非常重要。

#### 进程间通信的目的：

- 数据传输：一个进程将自己的数据传输给另一个进程。
- 资源共享：多个进程共享同一个资源。
- 通知事件：一个进程要给另一个进程去发送消息。
- 进程控制：一个进程想要去控制另一个进程，此时的控制想要拦截另一个进程的所有陷入和异常，并能够及时知道其状态的改变。

#### 管道 （匿名管道、命名管道）：是否通过管道文件 channel

1. 管道可以分为两类：匿名管道和命名管道。匿名管道是单向的，只能在有父子进程间通信；命名管道是双向的，可以实现本机任意两个进程通信。

2. 半双工通信：个管道有两个端口，每个端口都可以进行写入，或者读取资源，但是同一实际，相同的端口只能写入或者删除，不可同时进行。

3. 管道的本质：本质为内核的一个缓冲区（内核的一块物理内存），通过多个进程访问同一个缓冲区来实现通信（由于内核对所有的进程来说都是一样的，所以在内核中开辟一块内存用于交流）。

4. 匿名管道: 在内核中开辟这块内存，但是没有标识符，无法被其他进程找到。（所以匿名管道是针对于有亲缘关系的进程使用，例如：父子进程，由于子进程在通过父进程创建的时候，复制了父进程的文件描述信息，所以子进程也就有这个文件描述符去操作这个管道）
所以说，对于匿名管道，只有通过子进程去复制父进程的方式，才能获取同一个管道的操作句柄(变量/内存地址)。

5. 命名管道： 对于进程间的通信不可能只有父子间的通信，肯定还有没有亲缘关系的进程间通信，而对于这些进程，是通过命名管道进行通信的。

内核中开辟这一块缓冲区，并具有标识符，可以被其他进程找到。（适用于同一主机中没有亲缘关系的进程间通信）
对于一个进程创建了命名管道，这个命名管道会在文件系统中创建出一个管道文件（实际上是管道的名称），多个进程通过打开同一个管道文件，访问内核中的同一个缓冲区实现通信。

6. 管道的特性：

- 如果管道中没有数据，则read堵塞，如果管道中数据满了，则write堵塞。
- 管道中的读端关闭了（没有人去写入数据了），那么write会出发异常，进程退出。
- 在管道中，数据都是先入先出的。
- 进程退出，管道释放，所有管道生命周期是跟随其进程的。
- 内核会对管道的操作进行同步和互斥。
```
对于管道自带的同步和互斥

①：同步：按照一定的顺序去进行（写入数据的时候才能有数据被读取，没有数据，则read堵塞，数据满了，则write堵塞，读取了继续写）。

②：互斥：操作是安全可靠的（对于两个进程对一个管道文件写入的时候必须有数据，防止交叉写入，破坏数据原本的样子）；并且读写大小不能超过PIPE_BUF（也就是4096字节），大小保证原子操作。

③：原子操作：一次性完成，中间不能被打断。
```
#### 共享内存

1. 原理：因为对于共享内存，他是在物理内存上开辟一个内存块，然后对于有需要的的进程，会连接这个内存块，将其映射到自己的虚拟地址上，这样对于不同的进程对于这个内存的操作就不会涉及内核了，所以大大的减少了内核和用户直接沟通的那段时间，提高了效率，所以是最快的IPC。

3. 写入覆盖 
（1）写入共享内存后，数据不会消失，可以一直读取。
（2）再次向共享内存写入数据后，会覆盖共享内存之前的内容，也就是每次向共享内存写入数据，都是从相同位置写入的，这点和管道不同。

3. 共享内存的生命周期：

进程退出以后，共享内存依然存在，换到我们之前的匿名管道，管道的生命周期是随进程的，进程退出以后，管道也就不存在了。

进程可以调用函数接口与共享内存断开连接， 使共享内存的连接数减一， 共享内存即使连接数为0也不会去释放。因为共享内存不属于任何进程，不归进程管理，除非调用释放函数，否则要不要释放是OS决定的，因此共享内存的生命周期是随内核的！！

释放的方式有三种：
- 关机
- 调用释放共享内存的函数 shmctl
- 命令行释放

4. 共享内存中没有互斥同步关系。（通过信号量、信号等同步机制实现）


#### 消息队列 

1. 消息队列是消息的链接表，存放在内核中并由消息队列标识符标识。 可以通过发送消息来避免命名管道的同步和阻塞问题（命名管道要读端和写端都存在，否则出现阻塞）.

消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

基本原理：A进程要给B进程发送消息，A进程把数据放在对应的消息队列后就可以正常返回了，B进程需要的时候再去读取数据就可以了。

2. 特点：

1．消息队列是保存在内核中的消息链表，每个消息体都是固定大小的存储块。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。

2．如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。

3. 缺点：

1．通信不及时，附件也有大小限制。
2．消息队列不适合比较大数据的传输，每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限.
3．消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销

4. 消息队列与命名管道的比较
 
消息队列跟命名管道有不少的相同之处，通过与命名管道一样，消息队列进行通信的进程可以是不相关的进程，同时它们都是通过发送和接收的方式来传递数据的。在命名管道中，发送数据用write，接收数据用read，则在消息队列中，发送数据用msgsnd，接收数据用msgrcv。而且它们对每个数据都有一个最大长度的限制。
 
与命名管道相比，消息队列的优势在于
1、消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。
2、同时通过发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。
3、接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样，只能默认地接收。

#### 信号（软件中断）

信号可以理解成一种电报，发送方发送内容，指定接收进程，然后发出特定的**软件中断**，**操作系统接到中断请求**后，找到接收进程，通知接收进程处理信号。

信号是软件中断，它是在软件层次上对**中断**机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件；

信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了哪些系统事件.

1. 信号的特点 

- 简单

- 不能携带大量信息

- 满足某个特定条件才发送

2. 一个完整的信号周期

- 信号的产生

- 信号在进程中的注册，信号在进程中的注销

- 执行信号处理函数


3. 信号的（产生动作）和状态

（1）产生动作 ctrlz kill

    1．当用户按某些终端键时，将产生信号

    2．硬件异常将产生信号

    3．软件异常将产生信号

    4．调用系统函数（如：kill、raise、abort）将发送信号

    5．运行kill／killall命令将发送信号

（2）未决状态：没有被处理

（3）递达状态：信号被处理了


#### 信号量（PV操作）
1.本质：是内核中的一个**计数器**。

2.作用：实现进程间的同步与互斥（包含进程间对临界**资源的访问操作**）。主要作为进程间以及同一进程内不同线程之间的同步手段。
其中：临界资源就是大家都能访问到的资源，也就是我们需要传输的资源。

3.对于保护操作的方式也就是我们上面所说的同步和互斥：
①：同步：通过一些条件让资源访问有序。
②：互斥：通过让进程同一时间对资源进行唯一访问来保证资源安全。

4.信号量对同步和互斥的操作原理：
会通过计数器进行计数，若计数器大于0则表示可以访问资源，如果小于或者等于0，则不能去访问资源，进程堵塞。
其操作方式如下：

信号量表示资源的数量，控制信号量的⽅式有两种原⼦操作：
- ⼀个是 P 操作 ，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使⽤，进程可正常继续执⾏。
- 另⼀个是 V 操作 ，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中（在排队）的进程，于是会将该进程唤醒运⾏；相加后如果信号量> 0，则表明当前没有阻塞中的进程；

P 操作是⽤在进⼊共享资源之前，V 操作是⽤在离开共享资源之后，这两个操作是必须成对出现的

对于互斥和同步就像是在停车场停车一样，同步是在停车场门口进行的操作，排队驶入，而互斥就像是停车场内部对一个停车位进行的操作。


#### socket


### 进程调度策略

先来先服务、短作业优先、最短剩余时间优先

时间片轮转、优先级调度、多级队列

### 父进程；子进程；僵尸进程；孤儿进程

#### 父进程、子进程

pid = fork()

fork 返回值 -     0       +
          error  child   father

#### [僵尸进程](https://blog.csdn.net/theresnotomorrow/article/details/109858930)

一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁， 而是留下一个称为僵尸进程（Zombie）的数据结构(pid、status、time)。如果“尸体”僵尸进程没有得到处理，进程号pid被一直占用。 一般通过其父进程来处理这个僵尸进程。


僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源
我们都知道进程的工作原理。我们启动一个程序，开始我们的任务，然后等任务结束了，我们就停止这个进程。 进程停止后， 该进程就会从进程表中移除。
你可以通过 System-Monitor 查看当前进程。
 
 在UNIX系统中，一个进程结束了，但是它的父进程没有等待（调用wait / waitpid）它， 那么它将变成一个僵尸进程。 但是如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程， 因为每个进程结束的时候，系统都会扫描当前系统中所运行的所有进程， 看有没有哪个进程是刚刚结束的这个进程的子进程，如果是的话，就由Init来接管他，成为他的父进程

**处理方法：**
1. 父进程通过wait（）和waitpid（）等函数等待子进程结束，但是，这会导致父进程挂起；

2. 如果父进程要处理的事情很多，不能够挂起，通过signal（）函数人为处理信号 SIGCHLD：

只要有子进程退出自动调用指定好的回调函数，因为子进程结束后，父进程会收到该信号SIGCHLD，可以在其回调函数里调用 wait（）或waitpid（）回收；

3. 如果父进程不关心子进程什么时候结束，那么可以用signal（SIGCHLD，SIG＿IGN）通知内核：

自己对子进程的结束不感兴趣，父进程忽略此信号，那么子进程结束后，内核会回收，并不再给父进程发送信号：

#### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程 (进程 ID 为 1 的进程) 所收养，并由 init 进程对它们完成状态收集工作。因为孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。



## 线程

### 三种线程

### 特点 优点 缺点

### 通信 同步 互斥

### 上下文切换 占用资源情况 共享资源与独立资源 



