---
title: 操作系统
date: 2022-11-09 21:37:43
categories: 
 - 学习
---

# 基础

## 1.1 什么是操作系统

可以这么说，操作系统是在硬件资源之上，应用程序之下，运行在内核态的软件。
它是应用程序和硬件之间的媒介，向应用程序提供硬件的抽象，以及管理硬件资源。

## 1.2 操作系统四大功能模块

内存管理、进程管理、⽂件系统管理、输⼊输出设备管理
1. 进程调度能力：管理进程、线程，决定哪个进程、线程使用CPU。
2. 内存管理能力：决定内存的分配和回收。
3. 硬件通信能力：管理硬件，为进程和硬件之间提供通信。
4. 系统调用能力：应用程序进行更高限权运行的服务，需要系统调用，用户程序和操作系统之间的接口。

## 1.3 用户态、内核态

1. 权限：对硬件操作的权限：IO读写、内存分配等。

操作系统把一切对硬件的操作都对用户态的应用程序进行隐藏，应用程序是无法直接执行硬件使用和内存申请等操作。需要通过操作系统提供的**接口（函数库）（系统调用）切换成内核态**， 来完成上述需要高级权限的操作。

2. 空间：用户空间、内核空间。 

每个进程创建都会分配「虚拟空间地址」，一部分为内核空间，另一部分为用户空间。

用户态进程：只能操作用户空间的低位虚拟空间地址。

内核态进程：用户空间和内核空间的虚拟空间地址都可以操作。

补充：所有进程的内核空间地址是共享的（指所有进程的内核态逻辑地址是共享同一块内存地址），是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据

每个进程的 4G 虚拟空间地址，高位 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用，换句话说就是， 高位 1G 的内核空间是被所有进程共享的！

最后做个小结，我们通过指令集权限区分用户态和内核态，还限制了内存资源的使用，操作系统为用户态与内核态划分了两块内存空间，给它们对应的指令集使用

[从根上理解用户态与内核态](https://zhuanlan.zhihu.com/p/388057431)

中断：主要是用来打断cpu执行顺序的一种机制，CPU默认是按照代码的逻辑顺序来一条条执行的，运行起来后是属于不可控的（如果没有中断，你不能在执行的时候强行打断它），如果有键盘输入或者啥的紧急信号，输进来，你得去立刻处理吧，处理的话，要cpu吧，那中断就提供了一个乱序执行的机制，允许你暂停当前的执行，然后到中断中处理，处理完了，再接着执行，无缝衔接。中断是一个专门做这种事的系统。假如没这个系统，cpu正在处理某个数据，要10s才能处理完成，完成后还需要执行到键盘这部分的代码，才能处理键盘的数据，是不是觉得会很卡呢？

两者切换



# 程序、进程、线程

## 程序、进程、线程的区别与概念

- 程序：是一个静态的概念，一般对应于操作系统中的可执行的文件。当程序被加载到内存中执行时，这个运行的程序就被称为进程。

- 进程：是一个动态的概念，系统运行一个程序即是一个进程从创建，运行到消亡的过程，操作系统进行资源调度和分配的基本单位。

- 线程： 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。


## 2.1 进程

进程基本概念、 PCB组成、 进程状态、 进程切换、 进程间通信、 父进程；子进程；僵尸进程；孤儿进程 


### 1.2.1 PCB组成

PCB : 进程控制块

- 操作系统对进程的感知，是通过进程控制块 **PCB数据结构** 来描述的。它是进程存在的**唯一标识**

系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志。进程与PCB是一一对应的。

通常PCB应包含如下一些信息：
1. 进程标识符 name
    每个进程都必须有一个唯一的标识符，可以是字符串，也可以是一个数字。

2. 进程当前状态 status
    说明进程当前所处的状态。为了管理的方便，系统设计时会**将相同的状态的进程组成一个链表（队列）**，如就绪进程队列，等待进程则要根据等待的事件组成多个等待队列，如等待打印机队列。

<!-- 3. 进程相应的程序和数据地址
    以便把PCB与其程序和数据联系起来。 -->

4. 进程资源清单
    列出所拥有的除CPU外的资源记录，如拥有的I/O设备， 打开的文件列表等。

5. 进程优先级 priority
    进程的优先级反映进程的紧迫程度，通常由用户指定和系统设置。

6. CPU现场保护区 cpustatus
    当进程因某种原因不能继续占用CPU时（如等待打印机），释放CPU，这时就要将CPU的各种状态信息保护起来，为将来再次得到处理机恢复CPU的各种状态，继续运行。

7. 进程同步与通信机制
    用于实现进程间互斥、同步和通信所需的信号量等。

8. 进程所在队列PCB的链接字（当前PCB所在队列的下一个PCB地址）
    根据进程所处的现行状态，进程相应的PCB参加到不同队列中。PCB链接字指出该进程所在队列中下一个进程PCB的首地址。

9. 与进程有关的其他信息
    如进程记账信息，进程占用CPU的时间等。

### 1.2.2 进程状态

创建 就绪 运行 阻塞  

某个进程在某个时刻所处的状态分为以下几种，运行态running、就绪态ready、阻塞态wait。

对于阻塞状态；比如read系统调用阻塞，进程会占用内存空间，这是一种浪费行为，于是操作系统会有跟内存管理中物理页置换到磁盘一样的行为，把阻塞的进程置换到磁盘中，此时进程未占用物理内存。

我们称之为挂起；挂起不仅仅可能是物理内存不足，比如sleep系统调用过着用户执行Ctrl+Z也可能导致挂起。

除了创建和结束一般有三个状态：

运行态run：该时刻进程占用CPU

就绪态ready：可运行，由于其他进程处于运行状态而暂时停止运行

阻塞态wait：该进程正在等待某一事件发生（如等待输入／输出操作的完成）而暂时停止运行

阻塞态的进程占用着物理内存，在虚拟内存管理的操作系统中，通常会把阻塞态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。

挂起态：新的状态，描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现

就绪挂起状态：进程在外存（硬盘），但只要进入内存，马上运行

特点：

1.就绪态和运行态可以相互转换，其它的都是单向转换。就绪态的进程通过调度算法从而获得CPU时间，转为运行状态;

2.运行态的进程，在分配给它的CPU时间片用完之后就会转为就绪状态，等待下一次调度。

3.阻塞态是缺少需要的资源从而由运行态转换而来，但是该资源不包括CPU时间，缺少CPU时间会从运行态转换为就绪态。

### 进程上下文切换

### 进程间通信

### 进程调度策略

先来先服务、短作业优先、最短剩余时间优先

时间片轮转、优先级调度、多级队列

### 父进程；子进程；僵尸进程；孤儿进程

fork 返回值 -     0       +
          error  child   father


### 父进程 子进程 僵尸进程 孤儿进程 

## 1.3 线程



